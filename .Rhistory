# 清理旧编译文件
devtools::clean_dll()
# 重新完整编译安装
devtools::install()
library(reach)
p <- 100; m <- 1; q <- 50; n <- 100; r <- 3; s = 5
#'  mydata <- reach.sim(n, p, q, m, r, s, rho_X = .5, sigma_X = 1, s2n = 1)
#'
#'  Y <- mydata$Y
#'  X <- mydata$X
#'  Z_ <- mydata$Z_
#'
p <- 100; m <- 1; q <- 50; n <- 100; r <- 3; s = 5
mydata <- reach.sim(n, p, q, m, r, s, rho_X = .5, sigma_X = 1, s2n = 1)
library(reach)
p <- 100; m <- 1; q <- 50; n <- 100; r <- 3; s = 5
mydata <- reach.sim(n, p, q, m, r, s, rho_X = .5, sigma_X = 1, s2n = 1)
Y <- mydata$Y
X <- mydata$X
Z_ <- mydata$Z_
fit <- reach(Y, X, Z_, penalty = "MCP")
useDynLib(reach, .registration = TRUE)
remove.packages("reach")
install.packages("reach")
devtools::clean_dll()
devtools::install()
Rcpp::compileAttributes()
compileAttributes()
Rcpp::compileAttributes()
p <- 100; m <- 1; q <- 50; n <- 100; r <- 3; s = 5
mydata <- reach.sim(n, p, q, m, r, s, rho_X = .5, sigma_X = 1, s2n = 1)
Y <- mydata$Y
X <- mydata$X
Z_ <- mydata$Z_
fit <- reach(Y, X, Z_, penalty = "MCP")
devtools::clean_dll()  # 清理旧的 DLL 文件
devtools::install()
sourceRcpp("reach.cpp")
sourceRcpp("src/reach.cpp")
sourceRcpp("/src/reach.cpp")
sourceRcpp("./src/reach.cpp")
sourcecpp("/src/reach.cpp")
sourceCpp("reach.cpp")
library(Rcpp)
sourceCpp("reach.cpp")
library(Rcpp)
sourceCpp("src/reach.cpp")
library(Rcpp)
sourceCpp("G:\\Working\\努力\\磕盐\\2. Low-rank sparse multivariate subgroup analysis\\Code\\reach.R")
library(Rcpp)
sourceCpp("G:\\Working\\努力\\磕盐\\2. Low-rank sparse multivariate subgroup analysis\\Code\\reach\\src\\reach.cpp")
#' @title Simulate heterogeneous sparse reduced-rank regressions
#'
#' @description
#' Similar to the models in simulation examples 1-2 in Li et al. (2025)
#'
#' @param n,p,m,q model dimensions
#' @param r model rank
#' @param s model sparsity level
#' @param rho_X correlation parameter in the generation of covariates
#' @param sigma_X variance parameter in the generation of covariates
#' @param s2n signal to noise ratio
#'
#' @return similated model and data
#'
#' @export
reach.sim <- function(n, p, q, m, r, s, rho_X = .5, sigma_X = 1, s2n = 1){
# Generate X
Sigma_X <- matrix(nrow = p, ncol = p, rho_X)
diag(Sigma_X) <- sigma_X
X0 <- MASS::mvrnorm(max(n,p), rep(0,p), Sigma_X, empirical = TRUE)[1:n,]
X <- X0
# Generate Z_
if (m > 1){
Z_ <- matrix(rbinom((m-1)*n,1,.7), n)
Z_ <- cbind(rep(1,n),Z_)
}else{
Z_ <- matrix(1, n ,1)
}
# Generate Z
Z <- matrix(0, n, m*n)
for (i in 1:n){
Z[i,((i-1)*m+1):(i*m)] <- Z_[i,]
}
# Generate B
B1 <- matrix(rnorm(s*r,0,sigma_X), nrow = s, ncol = r)
B2 <- matrix(rnorm(r*q,0,sigma_X), nrow = r, ncol = q)
B <- rbind(B1%*%B2, matrix(0,nrow = p-s,ncol = q))
# Generate W
Theta1 <- matrix(rnorm(m*q,0.5,sigma_X), m, q)
Theta2 <- -Theta1
Theta3 <- matrix(rep(0,m*q), m, q)
Theta <- list(Theta1,Theta2,Theta3)
W <- matrix(0, nrow = m*n, ncol = q)
groups <- sample(1:3, n, replace = T)
for (i in 1:n){
W[((i-1)*m+1):(i*m),] <- Theta[[groups[i]]]
}
# Generate E
SigmaE <- matrix(0, nrow = q, ncol = q)
diag(SigmaE) <- sigma_X
E <- MASS::mvrnorm(max(n,q), rep(0,q), SigmaE, empirical = TRUE)[1:n,]
rd.XB <- svd(X%*%B)$d[r]
sigma <- rd.XB / (norm(E,"F")*s2n)
# Generate Y
Y = X%*%B + Z%*%W + sigma*E
# Output
list(Y = Y, X = X, B = B, Z_ = Z_, W = W, Theta = Theta, group = groups)
}
df=reach.sim(100,100,50,1,3,5)
df
fit=reach(df$Y, df$X, df$Z_)
#' @title Regularized rank-constrained heterogeneity pursuit (REACH)
#'
#' @description
#' Compute solutions of regularized rank-constrained heterogeneity pursuit
#'
#' @param Y response matrix
#' @param X covariate matrix
#' @param Z_ control variable matrix
#' @param U0 initial value of U; if NULL, generated by reduced-rank regression
#' @param V0 initial value of V; if NULL, generated by reduced-rank regression
#' @param W0 initial value of W; if NULL, generated by reduced-rank regression
#' @param penalty select penalty function for heterogeneity exploration; the default is MCP
#' @param lambda.B sequence of tuning parameters for B; if NULL, generated by a data driven procedure
#' @param lambda.W sequence of tuning parameters for W; if NULL, generated by a data driven procedure
#' @param r an integer specifying the desired rank; the default is 3
#' @param rho penalty parameter in augmented Lagrangian; the default is 1
#' @param a parameter that controls the concavity of penalty function; only useful for concave penalties; the default is 3
#' @param epsilon tolerance in algorithm; the default is 1e-3
#'
#' @return
#' A \code{REACH} object containing
##'   \item{call}{original function call}
##'   \item{Y}{input response matrix}
##'   \item{X}{input covariate matrix}
##'   \item{Z_}{input control variable matrix}
##'   \item{B}{estimated coefficient matrix for X}
##'   \item{W}{estimated coefficient matrix for Z}
##'   \item{Theta}{a list of estimated common value matrices}
##'   \item{C}{estimated pairwise difference matrix}
##'   \item{s}{estimated sparsity level}
##'   \item{p.index}{indices of covariates which passed screening}
##'   \item{r}{estimated rank}
##'   \item{group}{a vector of estimated group labels}
##'   \item{K}{estimated group number}
##'   \item{lambda.B}{selected tuning parameter for B}
##'   \item{lambda.W}{selected tuning parameter for W}
##'   \item{GIC}{GIC value for the fitted model}
##'   \item{iter}{iteration number}
##'   \item{res}{final residual in algorithm}
#'
#' @examples
#' library(reach)
#'  ## Simulate data from a heterogeneous sparse reduced-rank regression model
#'  p <- 100; m <- 1; q <- 50; n <- 100; r <- 3; s = 5
#'  mydata <- reach.sim(n, p, q, m, r, s, rho_X = .5, sigma_X = 1, s2n = 1)
#'
#'  Y <- mydata$Y
#'  X <- mydata$X
#'  Z_ <- mydata$Z_
#'
#'  fit <- reach(Y, X, Z_, penalty = "MCP")
#'
#'  fit$s
#'  fit$K
#'  fit$B
#'  fit$Theta
#'
#' @export
reach <- function(Y, X, Z_, U0 = NULL, V0 = NULL, W0 = NULL,
penalty = c("MCP", "SCAD", "L1"),
lambda.B = NULL, lambda.W = NULL, r = 3,
rho = 1, a = 3, epsilon = 1e-3)
{
# Record function call
Call <- match.call()
# Dimensions
p <- ncol(X); q <- ncol(Y); n <- nrow(Y); m <- ncol(Z_)
Z <- matrix(0, n, m*n)
# Z
for (i in 1:n){
Z[i,((i-1)*m+1):(i*m)] <- Z_[i,]
}
# Delta
flag <- 1
Delta_ <- matrix(0, n*(n-1)/2, n)
for (i in 1:(n-1)){
for (j in (i+1):n){
Delta_[flag,i] <- 1
Delta_[flag,j] <- -1
flag <- flag + 1
}
}
Delta <- kronecker(Delta_, diag(m))
# Initialization
library(rrpack)
if (is.null(U0)| is.null(V0) | is.null(W0)){
init.rrr <- rrpack::rrr(Y, X, maxrank = r, ic.type = "GIC")
svd.res <- svd(init.rrr$coef)
U0 <- svd.res$u %*% diag(sqrt(svd.res$d))
V0 <- svd.res$v %*% diag(sqrt(svd.res$d))
W0 <- MASS::ginv(t(Z)%*%Z) %*% t(Z) %*% (Y-X%*%U0%*%t(V0))
init.rrr <- rrpack::rrr(Y-Z%*%W0, X, maxrank = r, ic.type = "GIC")
svd.res <- svd(init.rrr$coef)
U0 <- svd.res$u %*% diag(sqrt(svd.res$d))
V0 <- svd.res$v %*% diag(sqrt(svd.res$d))
W0 <- MASS::ginv(t(Z)%*%Z) %*% t(Z) %*% (Y-X%*%U0%*%t(V0))
}
if (is.null(lambda.B) | is.null(lambda.W)){
lambda.B.factor <- norm(X,"2")/n*sqrt(log(p))
lambda.B <- seq(2*lambda.B.factor*1e-3, 2*lambda.B.factor, length.out = 10)
C0 <- Delta %*% W0
c0 <- matrix(t(C0), m*q, n*(n-1)/2)
lambda.W.max <- rho * max(apply(c0, 2, function(x) norm(x,"2")))
lambda.W <- seq(lambda.W.max*1e-3, lambda.W.max*1e-1, length.out = 10)
}
# Tuning
GIC.best <- GIC.old <- Inf
out.prev <- NULL
for (i in lambda.B){
for (j in lambda.W){
cat("lambda.B =", i, "lambda.W =", j, "r =", r, "\n")
if (is.null(out.prev)){
out <- reach_Rcpp(Y, X, Z, penalty, U0, V0, W0, r, i, j, rho, a, epsilon, 200, epsilon, 200)
}else{
out <- reach_Rcpp(Y, X, Z, penalty, out.prev$U, out.prev$V, out.prev$W, r, i, j, rho, a, epsilon, 200, epsilon, 200)
}
cat("K = ", out$K, ", s = ", out$s, "\n")
GIC.new <- out$GIC
cat("GIC =", GIC.new, "\n")
if (is.nan(GIC.new)) GIC.new <- Inf
if (GIC.new < GIC.best){
out.best <- out
lambda.B.best <- i
lambda.W.best <- j
GIC.best <- GIC.new
}
GIC.old <- GIC.new
}
}
# Estimate rank
svd.B <- svd(out.best$B)
d <- svd.B$d
mu <- 1/log(n) * log(log(n))
r.hat <- 0
for (k in (r-1):1){
if (d[k]-d[k+1] <= sqrt(q)*mu){
r.hat <- k + 1
}
}
# Refinement
if (r.hat != r){
if (r.hat == 0){
r <- 1
}else{
r <- r.hat
}
GIC.best <- GIC.old <- Inf
for (i in lambda.B){
for (j in lambda.W){
cat("lambda.B =", i, "lambda.W =", j, "r =", r, "\n")
if (i==1 & j== 1){
out <- reach_Rcpp(Y, X, Z, penalty, U0, V0, W0, r, i, j, rho, a, epsilon, 200, epsilon, 200)
}else{
out <- reach_Rcpp(Y, X, Z, penalty, out$U, out$V, out$W, r, i, j, rho, a, epsilon, 200, epsilon, 200)
}
cat("K = ", out$K, ", s = ", out$s, "\n")
GIC.new <- out$GIC
cat("GIC =", GIC.new, "\n")
if (is.nan(GIC.new)) GIC.new <- Inf
if (GIC.new < GIC.best){
out.best <- out
lambda.B.best <- i
lambda.W.best <- j
GIC.best <- GIC.new
}
GIC.old <- GIC.new
}
}
}
# Grouping
Theta <- list()
for (k in 1:out.best$K){
index <- which(out.best$G==k)
temp <- matrix(0,m,q)
for (i in 1:m){
if (length(index) > 1){
temp[i,] <- colMeans(out.best$W[((index-1)*m+i),])
}else{
temp[i,] <- out.best$W[((index-1)*m+i),]
}
}
Theta[[k]] <- temp
}
res <- list(Y = Y, X = X, Z_ = Z_,
B = out.best$B, W = out.best$W, Theta = Theta, C = out.best$C,
s = out.best$s, p.index = which(rowMeans(out.best$B)!=0), r = r,
group = c(out.best$G), K = out.best$K,
lambda.B = lambda.B.best, lambda.W = lambda.W.best, GIC = GIC.best,
iter = out.best$iter, res = out.best$res)
class(res) <- "REACH"
res
}
fit=reach(df$Y, df$X, df$Z_)
library(reach)
df=reach.sim(100,100,50,1,3,5)
devtools::clean_dll()  # 清理旧的 DLL 文件
devtools::install()
df=reach.sim(100,100,50,1,3,5)
fit=reach(df$Y, df$X, df$Z_)
devtools::clean_dll()  # 清理旧的 DLL 文件
devtools::install()
p <- 100; m <- 1; q <- 50; n <- 100; r <- 3; s = 5
mydata <- reach.sim(n, p, q, m, r, s, rho_X = .5, sigma_X = 1, s2n = 1)
devtools::install()

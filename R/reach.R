#' @title Regularized rank-constrained heterogeneity pursuit (REACH)
#'
#' @description
#' Compute solutions of regularized rank-constrained heterogeneity pursuit
#'
#' @param Y response matrix
#' @param X covariate matrix
#' @param Z_ control variable matrix
#' @param U0 initial value of U; if NULL, generated by reduced-rank regression
#' @param V0 initial value of V; if NULL, generated by reduced-rank regression
#' @param W0 initial value of W; if NULL, generated by reduced-rank regression
#' @param penalty select penalty function for heterogeneity exploration; the default is MCP
#' @param lambda.B sequence of tuning parameters for B; if NULL, generated by a data driven procedure
#' @param lambda.W sequence of tuning parameters for W; if NULL, generated by a data driven procedure
#' @param r an integer specifying the desired rank; the default is 3
#' @param rho penalty parameter in augmented Lagrangian; the default is 1
#' @param a parameter that controls the concavity of penalty function; only useful for concave penalties; the default is 3
#' @param epsilon tolerance in algorithm; the default is 1e-3
#'
#' @return
#' A \code{REACH} object containing
##'   \item{call}{original function call}
##'   \item{Y}{input response matrix}
##'   \item{X}{input covariate matrix}
##'   \item{Z_}{input control variable matrix}
##'   \item{B}{estimated coefficient matrix for X}
##'   \item{W}{estimated coefficient matrix for Z}
##'   \item{Theta}{a list of estimated common value matrices}
##'   \item{C}{estimated pairwise difference matrix}
##'   \item{s}{estimated sparsity level}
##'   \item{p.index}{indices of covariates which passed screening}
##'   \item{r}{estimated rank}
##'   \item{group}{a vector of estimated group labels}
##'   \item{K}{estimated group number}
##'   \item{lambda.B}{selected tuning parameter for B}
##'   \item{lambda.W}{selected tuning parameter for W}
##'   \item{GIC}{GIC value for the fitted model}
##'   \item{iter}{iteration number}
##'   \item{res}{final residual in algorithm}
#'
#' @examples
#' library(reach)
#'  ## Simulate data from a heterogeneous sparse reduced-rank regression model
#'  p <- 100; m <- 1; q <- 50; n <- 100; r <- 3; s = 5
#'  mydata <- reach.sim(n, p, q, m, r, s, rho_X = .5, sigma_X = 1, s2n = 1)
#'
#'  Y <- mydata$Y
#'  X <- mydata$X
#'  Z_ <- mydata$Z_
#'
#'  fit <- reach(Y, X, Z_, penalty = "MCP")
#'
#'  fit$s
#'  fit$K
#'  fit$B
#'  fit$Theta
#'
#' @useDynLib reach, .registration = TRUE
#' @importFrom Rcpp sourceCpp
#' @import rrpack
#'
#' @export
reach <- function(Y, X, Z_, U0 = NULL, V0 = NULL, W0 = NULL,
                      penalty = c("MCP", "SCAD", "L1"),
                      lambda.B = NULL, lambda.W = NULL, r = 3,
                      rho = 1, a = 3, epsilon = 1e-3)
{
  # Record function call
  Call <- match.call()
  # Dimensions
  p <- ncol(X); q <- ncol(Y); n <- nrow(Y); m <- ncol(Z_)
  Z <- matrix(0, n, m*n)
  # Z
  for (i in 1:n){
    Z[i,((i-1)*m+1):(i*m)] <- Z_[i,]
  }
  # Delta
  flag <- 1
  Delta_ <- matrix(0, n*(n-1)/2, n)
  for (i in 1:(n-1)){
    for (j in (i+1):n){
      Delta_[flag,i] <- 1
      Delta_[flag,j] <- -1
      flag <- flag + 1
    }
  }
  Delta <- kronecker(Delta_, diag(m))

  # Initialization
  library(rrpack)
  if (is.null(U0)| is.null(V0) | is.null(W0)){
    init.rrr <- rrpack::rrr(Y, X, maxrank = r, ic.type = "GIC")
    svd.res <- svd(init.rrr$coef)
    U0 <- svd.res$u %*% diag(sqrt(svd.res$d))
    V0 <- svd.res$v %*% diag(sqrt(svd.res$d))
    W0 <- MASS::ginv(t(Z)%*%Z) %*% t(Z) %*% (Y-X%*%U0%*%t(V0))
    init.rrr <- rrpack::rrr(Y-Z%*%W0, X, maxrank = r, ic.type = "GIC")
    svd.res <- svd(init.rrr$coef)
    U0 <- svd.res$u %*% diag(sqrt(svd.res$d))
    V0 <- svd.res$v %*% diag(sqrt(svd.res$d))
    W0 <- MASS::ginv(t(Z)%*%Z) %*% t(Z) %*% (Y-X%*%U0%*%t(V0))
  }
  if (is.null(lambda.B) | is.null(lambda.W)){
    lambda.B.factor <- norm(X,"2")/n*sqrt(log(p))
    lambda.B <- seq(2*lambda.B.factor*1e-3, 2*lambda.B.factor, length.out = 10)
    C0 <- Delta %*% W0
    c0 <- matrix(t(C0), m*q, n*(n-1)/2)
    lambda.W.max <- rho * max(apply(c0, 2, function(x) norm(x,"2")))
    lambda.W <- seq(lambda.W.max*1e-3, lambda.W.max*1e-1, length.out = 10)
  }

  # Tuning
  GIC.best <- GIC.old <- Inf
  out.prev <- NULL
  for (i in lambda.B){
    for (j in lambda.W){
      cat("lambda.B =", i, "lambda.W =", j, "r =", r, "\n")
      if (is.null(out.prev)){
        out <- reach_Rcpp(Y, X, Z, penalty, U0, V0, W0, r, i, j, rho, a, epsilon, 200, epsilon, 200)
      }else{
        out <- reach_Rcpp(Y, X, Z, penalty, out.prev$U, out.prev$V, out.prev$W, r, i, j, rho, a, epsilon, 200, epsilon, 200)
      }
      cat("K = ", out$K, ", s = ", out$s, "\n")
      GIC.new <- out$GIC
      cat("GIC =", GIC.new, "\n")
      if (is.nan(GIC.new)) GIC.new <- Inf
      if (GIC.new < GIC.best){
        out.best <- out
        lambda.B.best <- i
        lambda.W.best <- j
        GIC.best <- GIC.new
      }
      GIC.old <- GIC.new
    }
  }
  # Estimate rank
  svd.B <- svd(out.best$B)
  d <- svd.B$d
  mu <- 1/log(n) * log(log(n))
  r.hat <- 0
  for (k in (r-1):1){
    if (d[k]-d[k+1] <= sqrt(q)*mu){
      r.hat <- k + 1
    }
  }
  # Refinement
  if (r.hat != r){
    if (r.hat == 0){
      r <- 1
    }else{
      r <- r.hat
    }
    GIC.best <- GIC.old <- Inf
    for (i in lambda.B){
      for (j in lambda.W){
        cat("lambda.B =", i, "lambda.W =", j, "r =", r, "\n")
        if (i==1 & j== 1){
          out <- reach_Rcpp(Y, X, Z, penalty, U0, V0, W0, r, i, j, rho, a, epsilon, 200, epsilon, 200)
        }else{
          out <- reach_Rcpp(Y, X, Z, penalty, out$U, out$V, out$W, r, i, j, rho, a, epsilon, 200, epsilon, 200)
        }
        cat("K = ", out$K, ", s = ", out$s, "\n")
        GIC.new <- out$GIC
        cat("GIC =", GIC.new, "\n")
        if (is.nan(GIC.new)) GIC.new <- Inf
        if (GIC.new < GIC.best){
          out.best <- out
          lambda.B.best <- i
          lambda.W.best <- j
          GIC.best <- GIC.new
        }
        GIC.old <- GIC.new
      }
    }
  }

  # Grouping
  Theta <- list()
  for (k in 1:out.best$K){
    index <- which(out.best$G==k)
    temp <- matrix(0,m,q)
    for (i in 1:m){
      if (length(index) > 1){
        temp[i,] <- colMeans(out.best$W[((index-1)*m+i),])
      }else{
        temp[i,] <- out.best$W[((index-1)*m+i),]
      }
    }
    Theta[[k]] <- temp
  }

  res <- list(Y = Y, X = X, Z_ = Z_,
              B = out.best$B, W = out.best$W, Theta = Theta, C = out.best$C,
              s = out.best$s, p.index = which(rowMeans(out.best$B)!=0), r = r,
              group = c(out.best$G), K = out.best$K,
              lambda.B = lambda.B.best, lambda.W = lambda.W.best, GIC = GIC.best,
              iter = out.best$iter, res = out.best$res)
  class(res) <- "REACH"
  res
}
